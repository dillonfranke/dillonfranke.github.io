<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Dillon Franke Security</title><link>https://www.dillonfrankesecurity.com/posts/</link><description>Recent content in Posts on Dillon Franke Security</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 03 Mar 2023 11:40:07 -0800</lastBuildDate><atom:link href="https://www.dillonfrankesecurity.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Java Static Vulnerability Analysis to Increase Your Bounty</title><link>https://www.dillonfrankesecurity.com/posts/java-static-vulnerability-analysis-to-increase-your-bounty/</link><pubDate>Fri, 03 Mar 2023 11:40:07 -0800</pubDate><guid>https://www.dillonfrankesecurity.com/posts/java-static-vulnerability-analysis-to-increase-your-bounty/</guid><description>If you want to get serious about finding impactful vulnerabilities through static analysis, it’s time to move beyond simply grep-ing through code bases. In this blog post, I’ll share my personal process for setting up a robust environment for Java static analysis of console applications, web applications, and Android applications. Once you’ve established this test environment, you’ll be able to take advantage of automatic code references, trace usages across a code base, and leverage source-to-sink analysis to find elusive vulnerabilities.</description></item></channel></rss>